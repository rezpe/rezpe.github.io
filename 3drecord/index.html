<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue.js 3D Pose Estimation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Ensure the canvas and video fill their container */
        #threeContainer canvas, #videoContainer video, #videoContainer canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="app"></div>

    <script type="importmap">
    {
        "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
            "three": "https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.module.js",
            "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
        }
    }
    </script>

    <script type="module">
        import { createApp, ref, onMounted } from 'vue';
        import * as THREE from 'three';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.151.3/examples/jsm/controls/OrbitControls.js';
        import { PoseLandmarker, FilesetResolver, DrawingUtils } from "@mediapipe/tasks-vision";

        const App = {
            template: `
                <div class="min-h-screen flex flex-col items-center justify-center p-4">
                    <h1 class="text-4xl font-bold mb-4">3D Pose Estimation</h1>
                    <p class="text-lg mb-8 text-center max-w-2xl">This application uses your webcam to detect your body pose in real-time and renders a 3D skeleton using Three.js.</p>
                    
                    <div class="w-full max-w-6xl aspect-video rounded-lg shadow-2xl bg-black overflow-hidden flex">
                        <!-- 3D Canvas on the left -->
                        <div ref="threeContainer" id="threeContainer" class="w-1/2 h-full"></div>
                        
                        <!-- Video feed on the right -->
                        <div id="videoContainer" class="w-1/2 h-full relative">
                             <video ref="video" class="w-full h-full object-cover transform scale-x-[-1]" autoplay playsinline></video>
                             <canvas ref="overlayCanvas" class="w-full h-full"></canvas>
                        </div>

                        <!-- Loading Indicator -->
                        <div v-if="loading" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center z-10">
                            <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-blue-500"></div>
                            <p class="mt-4 text-lg">{{ loadingMessage }}</p>
                        </div>
                    </div>
                     <div class="mt-8 flex space-x-4">
                        <button @click="toggleRecording" class="px-6 py-2 rounded-lg text-white font-semibold shadow-md transition-transform transform hover:scale-105" :class="isRecording ? 'bg-red-600 hover:bg-red-700' : 'bg-blue-600 hover:bg-blue-700'">
                            {{ isRecording ? 'Stop' : 'Record' }}
                        </button>
                        <button v-if="!isRecording && recordedData.length > 0" @click="playRecording" class="px-6 py-2 rounded-lg text-white font-semibold bg-green-600 hover:bg-green-700 shadow-md transition-transform transform hover:scale-105">
                            Play
                        </button>
                        <button v-if="!isRecording && recordedData.length > 0" @click="downloadRecording" class="px-6 py-2 rounded-lg text-white font-semibold bg-gray-600 hover:bg-gray-700 shadow-md transition-transform transform hover:scale-105">
                            Download
                        </button>
                    </div>
                </div>
            `,
            setup() {
                const threeContainer = ref(null);
                const video = ref(null);
                const overlayCanvas = ref(null);
                const loading = ref(true);
                const loadingMessage = ref('Initializing...');

                // Recording and playback state
                const isRecording = ref(false);
                const isPlaying = ref(false);
                const recordedData = ref([]);
                let playbackFrame = 0;

                let scene, camera, renderer, controls;
                let poseLandmarker;
                let skeletonGroup;
                let lastVideoTime = -1;
                let drawingUtils;

                // Smoothing variables
                let smoothedLandmarks = [];
                const smoothingFactor = 0.25;

                // Three.js setup
                const initThree = () => {
                    scene = new THREE.Scene();
                    const containerRect = threeContainer.value.getBoundingClientRect();
                    camera = new THREE.PerspectiveCamera(75, containerRect.width / containerRect.height, 0.1, 1000);
                    camera.position.set(0, 0, 8);

                    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                    renderer.setSize(containerRect.width, containerRect.height);
                    threeContainer.value.appendChild(renderer.domElement);
                    
                    controls = new OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;

                    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                    scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(0, 1, 1);
                    scene.add(directionalLight);

                    const gridHelper = new THREE.GridHelper(20, 20);
                    scene.add(gridHelper);

                    skeletonGroup = new THREE.Group();
                    scene.add(skeletonGroup);
                };
                
                // MediaPipe setup
                const initMediaPipe = async () => {
                    loadingMessage.value = 'Loading AI models...';
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numPoses: 1
                    });
                     loadingMessage.value = 'Starting camera...';
                };

                // Start webcam
                const startWebcam = async () => {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            video: { width: 1280, height: 720 },
                            audio: false 
                        });
                        video.value.srcObject = stream;
                        video.value.addEventListener("loadeddata", () => {
                            overlayCanvas.value.width = video.value.videoWidth;
                            overlayCanvas.value.height = video.value.videoHeight;
                            drawingUtils = new DrawingUtils(overlayCanvas.value.getContext("2d"));
                            predictWebcam();
                        });
                    } catch (error) {
                        console.error("Error accessing webcam:", error);
                        loadingMessage.value = 'Error accessing webcam. Please grant permission.';
                    }
                };
                
                // Main prediction loop
                const predictWebcam = async () => {
                    // If playing back, don't run prediction
                    if (isPlaying.value) {
                        requestAnimationFrame(predictWebcam);
                        return;
                    }

                    if (!video.value || !poseLandmarker) {
                         requestAnimationFrame(predictWebcam);
                         return;
                    }
                    
                    loading.value = false;
                    const nowInMs = performance.now();
                    if (video.value.readyState >= 2 && video.value.currentTime !== lastVideoTime) {
                        lastVideoTime = video.value.currentTime;
                        const results = poseLandmarker.detectForVideo(video.value, Math.round(nowInMs));
                        
                        const canvasCtx = overlayCanvas.value.getContext("2d");
                        canvasCtx.save();
                        canvasCtx.clearRect(0, 0, overlayCanvas.value.width, overlayCanvas.value.height);
                        
                        canvasCtx.scale(-1, 1);
                        canvasCtx.translate(-overlayCanvas.value.width, 0);

                        if (results.landmarks) {
                            for (const landmark of results.landmarks) {
                                drawingUtils.drawLandmarks(landmark, {
                                    radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1)
                                });
                                drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
                            }
                        }
                        canvasCtx.restore();

                        updateSkeleton(results.landmarks);
                    }
                    requestAnimationFrame(predictWebcam);
                };

                // Update Three.js skeleton
                const updateSkeleton = (landmarks) => {
                    while(skeletonGroup.children.length > 0){ 
                        const child = skeletonGroup.children[0];
                        skeletonGroup.remove(child);
                        if(child.geometry) child.geometry.dispose();
                        if(child.material) child.material.dispose();
                    }

                    if (landmarks && landmarks.length > 0) {
                        const landmarkPoints = landmarks[0];

                        // During live view, smooth the landmarks
                        if (!isPlaying.value) {
                             if (smoothedLandmarks.length === 0) {
                                smoothedLandmarks = landmarkPoints.map(lm => ({ ...lm }));
                            }

                            landmarkPoints.forEach((landmark, index) => {
                                const oldPos = smoothedLandmarks[index];
                                smoothedLandmarks[index] = {
                                    x: THREE.MathUtils.lerp(oldPos.x, landmark.x, smoothingFactor),
                                    y: THREE.MathUtils.lerp(oldPos.y, landmark.y, smoothingFactor),
                                    z: THREE.MathUtils.lerp(oldPos.z, landmark.z, smoothingFactor),
                                    visibility: landmark.visibility
                                };
                            });
                        }
                        
                        // If recording, save the current smoothed frame
                        if (isRecording.value) {
                            recordedData.value.push(JSON.parse(JSON.stringify(smoothedLandmarks)));
                        }

                        // Use smoothed landmarks for live view, and raw landmarks for playback
                        const pointsToDraw = isPlaying.value ? landmarkPoints : smoothedLandmarks;

                        pointsToDraw.forEach(landmark => {
                            const geometry = new THREE.SphereGeometry(0.06, 16, 16);
                            const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x228B22 });
                            const sphere = new THREE.Mesh(geometry, material);
                            
                            sphere.position.set(
                                (0.5 - landmark.x) * 10, 
                                (0.5 - landmark.y) * 10, 
                                -landmark.z * 10 
                            );
                            skeletonGroup.add(sphere);
                        });

                        const connections = PoseLandmarker.POSE_CONNECTIONS;
                        connections.forEach(connection => {
                            const start = pointsToDraw[connection.start];
                            const end = pointsToDraw[connection.end];
                            
                            const material = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 5 });
                            const points = [];
                            points.push(new THREE.Vector3((0.5 - start.x) * 10, (0.5 - start.y) * 10, -start.z * 10));
                            points.push(new THREE.Vector3((0.5 - end.x) * 10, (0.5 - end.y) * 10, -end.z * 10));
                            
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, material);
                            skeletonGroup.add(line);
                        });
                    }
                };
                
                // --- Recording and Playback Functions ---
                const toggleRecording = () => {
                    if (isRecording.value) {
                        isRecording.value = false;
                    } else {
                        isRecording.value = true;
                        recordedData.value = []; // Clear previous recording
                    }
                };

                const playRecording = () => {
                    if (recordedData.value.length === 0) return;
                    isPlaying.value = true;
                    playbackFrame = 0;
                    
                    const playbackLoop = () => {
                        if (!isPlaying.value || playbackFrame >= recordedData.value.length) {
                            isPlaying.value = false;
                            return;
                        }
                        
                        // Update skeleton with the recorded frame
                        updateSkeleton([recordedData.value[playbackFrame]]);
                        
                        playbackFrame++;
                        requestAnimationFrame(playbackLoop);
                    };
                    playbackLoop();
                };

                const downloadRecording = () => {
                    if (recordedData.value.length === 0) return;
                    const jsonString = JSON.stringify(recordedData.value, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'pose-animation.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };


                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };

                onMounted(async () => {
                    initThree();
                    await initMediaPipe();
                    await startWebcam();
                    animate();

                    window.addEventListener('resize', () => {
                        if (threeContainer.value) {
                            const containerRect = threeContainer.value.getBoundingClientRect();
                            camera.aspect = containerRect.width / containerRect.height;
                            camera.updateProjectionMatrix();
                            renderer.setSize(containerRect.width, containerRect.height);
                        }
                    });
                });

                return {
                    threeContainer,
                    video,
                    overlayCanvas,
                    loading,
                    loadingMessage,
                    isRecording,
                    recordedData,
                    toggleRecording,
                    playRecording,
                    downloadRecording
                };
            }
        };

        createApp(App).mount('#app');
    </script>
</body>
</html>
